// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryGetFeeStatsResponse } from "./types/stwartchain/stats/query";
import { MsgUpdateParamsResponse } from "./types/stwartchain/stats/tx";
import { QueryDateRequest } from "./types/stwartchain/stats/query";
import { QueryUserStatsResponse } from "./types/stwartchain/stats/query";
import { UserStats } from "./types/stwartchain/stats/user_stats";
import { AssetStats } from "./types/stwartchain/stats/stats";
import { MsgUpdateParams } from "./types/stwartchain/stats/tx";
import { QueryDateWithPaginationRequest } from "./types/stwartchain/stats/query";
import { QueryAllFeeStatsRequest } from "./types/stwartchain/stats/query";
import { QueryGetFeeStatsByIndexesRequest } from "./types/stwartchain/stats/query";
import { Params } from "./types/stwartchain/stats/params";
import { QueryGetFeeStatsRequest } from "./types/stwartchain/stats/query";
import { FeeStats } from "./types/stwartchain/stats/fee_stats";
import { FeeDailyStats } from "./types/stwartchain/stats/fee_daily_stats";
import { QueryAssetStatsResponse } from "./types/stwartchain/stats/query";
import { QueryAllFeeStatsResponse } from "./types/stwartchain/stats/query";
import { QueryGetFeeStatsByDateRequest } from "./types/stwartchain/stats/query";
import { GenesisState } from "./types/stwartchain/stats/genesis";
import { QueryParamsRequest } from "./types/stwartchain/stats/query";
import { QueryParamsResponse } from "./types/stwartchain/stats/query";
import { AssetDailyStats } from "./types/stwartchain/stats/asset_stats";


export { QueryGetFeeStatsResponse, MsgUpdateParamsResponse, QueryDateRequest, QueryUserStatsResponse, UserStats, AssetStats, MsgUpdateParams, QueryDateWithPaginationRequest, QueryAllFeeStatsRequest, QueryGetFeeStatsByIndexesRequest, Params, QueryGetFeeStatsRequest, FeeStats, FeeDailyStats, QueryAssetStatsResponse, QueryAllFeeStatsResponse, QueryGetFeeStatsByDateRequest, GenesisState, QueryParamsRequest, QueryParamsResponse, AssetDailyStats };

type sendQueryGetFeeStatsResponseParams = {
  value: QueryGetFeeStatsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryDateRequestParams = {
  value: QueryDateRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryUserStatsResponseParams = {
  value: QueryUserStatsResponse,
  fee?: StdFee,
  memo?: string
};

type sendUserStatsParams = {
  value: UserStats,
  fee?: StdFee,
  memo?: string
};

type sendAssetStatsParams = {
  value: AssetStats,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryDateWithPaginationRequestParams = {
  value: QueryDateWithPaginationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFeeStatsRequestParams = {
  value: QueryAllFeeStatsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFeeStatsByIndexesRequestParams = {
  value: QueryGetFeeStatsByIndexesRequest,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFeeStatsRequestParams = {
  value: QueryGetFeeStatsRequest,
  fee?: StdFee,
  memo?: string
};

type sendFeeStatsParams = {
  value: FeeStats,
  fee?: StdFee,
  memo?: string
};

type sendFeeDailyStatsParams = {
  value: FeeDailyStats,
  fee?: StdFee,
  memo?: string
};

type sendQueryAssetStatsResponseParams = {
  value: QueryAssetStatsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFeeStatsResponseParams = {
  value: QueryAllFeeStatsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFeeStatsByDateRequestParams = {
  value: QueryGetFeeStatsByDateRequest,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendAssetDailyStatsParams = {
  value: AssetDailyStats,
  fee?: StdFee,
  memo?: string
};


type queryGetFeeStatsResponseParams = {
  value: QueryGetFeeStatsResponse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type queryDateRequestParams = {
  value: QueryDateRequest,
};

type queryUserStatsResponseParams = {
  value: QueryUserStatsResponse,
};

type userStatsParams = {
  value: UserStats,
};

type assetStatsParams = {
  value: AssetStats,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryDateWithPaginationRequestParams = {
  value: QueryDateWithPaginationRequest,
};

type queryAllFeeStatsRequestParams = {
  value: QueryAllFeeStatsRequest,
};

type queryGetFeeStatsByIndexesRequestParams = {
  value: QueryGetFeeStatsByIndexesRequest,
};

type paramsParams = {
  value: Params,
};

type queryGetFeeStatsRequestParams = {
  value: QueryGetFeeStatsRequest,
};

type feeStatsParams = {
  value: FeeStats,
};

type feeDailyStatsParams = {
  value: FeeDailyStats,
};

type queryAssetStatsResponseParams = {
  value: QueryAssetStatsResponse,
};

type queryAllFeeStatsResponseParams = {
  value: QueryAllFeeStatsResponse,
};

type queryGetFeeStatsByDateRequestParams = {
  value: QueryGetFeeStatsByDateRequest,
};

type genesisStateParams = {
  value: GenesisState,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type assetDailyStatsParams = {
  value: AssetDailyStats,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryGetFeeStatsResponse({ value, fee, memo }: sendQueryGetFeeStatsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFeeStatsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFeeStatsResponse({ value: QueryGetFeeStatsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFeeStatsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryDateRequest({ value, fee, memo }: sendQueryDateRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryDateRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryDateRequest({ value: QueryDateRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryDateRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryUserStatsResponse({ value, fee, memo }: sendQueryUserStatsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryUserStatsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryUserStatsResponse({ value: QueryUserStatsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryUserStatsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendUserStats({ value, fee, memo }: sendUserStatsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendUserStats: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.userStats({ value: UserStats.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendUserStats: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAssetStats({ value, fee, memo }: sendAssetStatsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAssetStats: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.assetStats({ value: AssetStats.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAssetStats: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryDateWithPaginationRequest({ value, fee, memo }: sendQueryDateWithPaginationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryDateWithPaginationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryDateWithPaginationRequest({ value: QueryDateWithPaginationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryDateWithPaginationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFeeStatsRequest({ value, fee, memo }: sendQueryAllFeeStatsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFeeStatsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFeeStatsRequest({ value: QueryAllFeeStatsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFeeStatsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFeeStatsByIndexesRequest({ value, fee, memo }: sendQueryGetFeeStatsByIndexesRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFeeStatsByIndexesRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFeeStatsByIndexesRequest({ value: QueryGetFeeStatsByIndexesRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFeeStatsByIndexesRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFeeStatsRequest({ value, fee, memo }: sendQueryGetFeeStatsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFeeStatsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFeeStatsRequest({ value: QueryGetFeeStatsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFeeStatsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFeeStats({ value, fee, memo }: sendFeeStatsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFeeStats: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.feeStats({ value: FeeStats.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFeeStats: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFeeDailyStats({ value, fee, memo }: sendFeeDailyStatsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFeeDailyStats: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.feeDailyStats({ value: FeeDailyStats.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFeeDailyStats: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAssetStatsResponse({ value, fee, memo }: sendQueryAssetStatsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAssetStatsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAssetStatsResponse({ value: QueryAssetStatsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAssetStatsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFeeStatsResponse({ value, fee, memo }: sendQueryAllFeeStatsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFeeStatsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFeeStatsResponse({ value: QueryAllFeeStatsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFeeStatsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFeeStatsByDateRequest({ value, fee, memo }: sendQueryGetFeeStatsByDateRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFeeStatsByDateRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFeeStatsByDateRequest({ value: QueryGetFeeStatsByDateRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFeeStatsByDateRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAssetDailyStats({ value, fee, memo }: sendAssetDailyStatsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAssetDailyStats: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.assetDailyStats({ value: AssetDailyStats.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAssetDailyStats: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryGetFeeStatsResponse({ value }: queryGetFeeStatsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryGetFeeStatsResponse", value: QueryGetFeeStatsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFeeStatsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryDateRequest({ value }: queryDateRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryDateRequest", value: QueryDateRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryDateRequest: Could not create message: ' + e.message)
			}
		},
		
		queryUserStatsResponse({ value }: queryUserStatsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryUserStatsResponse", value: QueryUserStatsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryUserStatsResponse: Could not create message: ' + e.message)
			}
		},
		
		userStats({ value }: userStatsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.UserStats", value: UserStats.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:UserStats: Could not create message: ' + e.message)
			}
		},
		
		assetStats({ value }: assetStatsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.AssetStats", value: AssetStats.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AssetStats: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryDateWithPaginationRequest({ value }: queryDateWithPaginationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryDateWithPaginationRequest", value: QueryDateWithPaginationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryDateWithPaginationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllFeeStatsRequest({ value }: queryAllFeeStatsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryAllFeeStatsRequest", value: QueryAllFeeStatsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFeeStatsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetFeeStatsByIndexesRequest({ value }: queryGetFeeStatsByIndexesRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryGetFeeStatsByIndexesRequest", value: QueryGetFeeStatsByIndexesRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFeeStatsByIndexesRequest: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryGetFeeStatsRequest({ value }: queryGetFeeStatsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryGetFeeStatsRequest", value: QueryGetFeeStatsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFeeStatsRequest: Could not create message: ' + e.message)
			}
		},
		
		feeStats({ value }: feeStatsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.FeeStats", value: FeeStats.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:FeeStats: Could not create message: ' + e.message)
			}
		},
		
		feeDailyStats({ value }: feeDailyStatsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.FeeDailyStats", value: FeeDailyStats.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:FeeDailyStats: Could not create message: ' + e.message)
			}
		},
		
		queryAssetStatsResponse({ value }: queryAssetStatsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryAssetStatsResponse", value: QueryAssetStatsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAssetStatsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllFeeStatsResponse({ value }: queryAllFeeStatsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryAllFeeStatsResponse", value: QueryAllFeeStatsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFeeStatsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetFeeStatsByDateRequest({ value }: queryGetFeeStatsByDateRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryGetFeeStatsByDateRequest", value: QueryGetFeeStatsByDateRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFeeStatsByDateRequest: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		assetDailyStats({ value }: assetDailyStatsParams): EncodeObject {
			try {
				return { typeUrl: "/stwartchain.stats.AssetDailyStats", value: AssetDailyStats.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AssetDailyStats: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			StwartchainStats: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;